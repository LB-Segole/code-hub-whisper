// This file is automatically generated. Do not edit it directly.
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { logger } from './logger';

// Environment variables (ensure these are set in your deployment)
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

// Session ID for logging context
const supabaseSessionId = logger.createAudioSessionId();

// Validate env vars
if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
  const error = new Error('Missing Supabase environment variables');
  logger.logError('Supabase initialization failed', error, {
    hasUrl: !!SUPABASE_URL,
    hasAnonKey: !!SUPABASE_ANON_KEY,
    context: 'supabase-init',
    sessionId: supabaseSessionId,
  });
  throw error;
}

// Primary Supabase client with enhanced logging
export const supabase: SupabaseClient<Database> = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_ANON_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      onAuthStateChange: (event, session) => {
        logger.logInfo('Supabase auth state change', {
          event,
          userId: session?.user?.id,
          sessionId: supabaseSessionId,
          context: 'supabase-auth',
        });
      },
    },
    realtime: {
      params: {
        eventsPerSecond: 10,
      },
      log_level: 'info',
    },
  }
);

// Health check utility
export const monitorSupabaseConnection = async (): Promise<boolean> => {
  const startTime = performance.now();
  return logger.measureAudioOperation('supabase-health-check', async () => {
    try {
      const { data, error } = await supabase
        .from('calls')
        .select('id')
        .limit(1)
        .single();

      if (error && (error.code as string) !== 'PGRST116') {
        throw error;
      }

      logger.logInfo('Supabase connection healthy', {
        responseTime: performance.now() - startTime,
        sessionId: supabaseSessionId,
        context: 'connection-health',
      });
      return true;
    } catch (error) {
      logger.logError('Supabase connection unhealthy', error as Error, {
        responseTime: performance.now() - startTime,
        sessionId: supabaseSessionId,
        context: 'connection-health',
      });
      return false;
    }
  });
};

// Real-time subscriptions and utilities
export const subscribeToCallUpdates = (
  callId: string,
  callback: (payload: any) => void
) => {
  const subscriptionId = `call-${callId}`;

  logger.logInfo('Starting call updates subscription', {
    callId,
    subscriptionId,
    sessionId: supabaseSessionId,
    context: 'supabase-realtime',
  });

  const channel = supabase
    .channel(subscriptionId)
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'calls', filter: `id=eq.${callId}` },
      (payload) => {
        logger.logAudioWebSocket('Call update received', {
          callId,
          event: payload.eventType,
          table: 'calls',
          sessionId: supabaseSessionId,
          context: 'call-updates',
        });
        callback(payload);
      }
    )
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'call_logs', filter: `call_id=eq.${callId}` },
      (payload) => {
        logger.logAudioWebSocket('Call log update received', {
          callId,
          event: payload.eventType,
          table: 'call_logs',
          sessionId: supabaseSessionId,
          context: 'call-logs',
        });
        callback(payload);
      }
    )
    .subscribe((status) => {
      if (status === 'SUBSCRIBED') {
        logger.logInfo('Call updates subscription active', {
          callId,
          subscriptionId,
          sessionId: supabaseSessionId,
        });
      } else if (status === 'CHANNEL_ERROR') {
        logger.logError('Call updates subscription failed', new Error('Channel error'), {
          callId,
          subscriptionId,
          status,
          sessionId: supabaseSessionId,
        });
      }
    });

  return channel;
};

export const subscribeToActiveCallsUpdates = (
  userId: string,
  callback: (payload: any) => void,
  audioSessionId?: string
) => {
  const subscriptionId = `user-calls-${userId}`;
  const contextSessionId = audioSessionId || logger.createAudioSessionId();

  logger.logInfo('Starting active calls subscription', {
    userId,
    subscriptionId,
    audioSessionId: contextSessionId,
    sessionId: supabaseSessionId,
    context: 'active-calls-subscription',
  });

  return supabase
    .channel(subscriptionId)
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'calls', filter: `user_id=eq.${userId}` },
      (payload) => {
        logger.logAudioWebSocket('Active call update received', {
          userId,
          event: payload.eventType,
          audioSessionId: contextSessionId,
          sessionId: supabaseSessionId,
          context: 'active-calls-update',
        });
        callback(payload);
      }
    )
    .subscribe((status) => {
      if (status === 'SUBSCRIBED') {
        logger.logInfo('Active calls subscription active', {
          userId,
          subscriptionId,
          audioSessionId: contextSessionId,
          sessionId: supabaseSessionId,
        });
      } else if (status === 'CHANNEL_ERROR') {
        logger.logError('Active calls subscription failed', new Error('Channel error'), {
          userId,
          subscriptionId,
          status,
          audioSessionId: contextSessionId,
          sessionId: supabaseSessionId,
        });
      }
    });
};

// Cleanup utilities
export const cleanupSubscription = (channel: any, subscriptionId: string) => {
  if (channel) {
    logger.logInfo('Cleaning up subscription', {
      subscriptionId,
      sessionId: supabaseSessionId,
      context: 'subscription-cleanup',
    });
    channel.unsubscribe();
  }
};

export const cleanupAllSubscriptions = () => {
  logger.logInfo('Cleaning up all Supabase subscriptions', {
    sessionId: supabaseSessionId,
    context: 'cleanup-all',
  });
  supabase.removeAllChannels();
};

// Admin client with error handling
export const supabaseAdmin: SupabaseClient<Database> | null = (() => {
  if (!SUPABASE_SERVICE_ROLE_KEY) {
    logger.logWarning('Supabase admin client not available - missing service role key', {
      sessionId: supabaseSessionId,
      context: 'supabase-admin-init',
    });
    return null;
  }

  try {
    const adminClient = createClient<Database>(
      SUPABASE_URL,
      SUPABASE_SERVICE_ROLE_KEY,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false,
        },
      }
    );
    logger.logInfo('Supabase admin client initialized', {
      sessionId: supabaseSessionId,
      context: 'supabase-admin-init',
    });
    return adminClient;
  } catch (error) {
    logger.logError('Failed to initialize Supabase admin client', error as Error, {
      sessionId: supabaseSessionId,
      context: 'supabase-admin-init',
    });
    return null;
  }
})();
